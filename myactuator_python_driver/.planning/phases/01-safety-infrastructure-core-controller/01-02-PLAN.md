---
phase: 01-safety-infrastructure-core-controller
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - myactuator_python_driver/calibrator/main.py
  - setup.py
autonomous: false

must_haves:
  truths:
    - "User can invoke the calibrator as a ROS 2 console_scripts entry point"
    - "Headless entry point creates RosBridge, RecordingManager, and CalibrationController with correct wiring"
    - "CalibrationController start/stop/emergency_stop sequence works end-to-end against connected driver"
  artifacts:
    - path: "myactuator_python_driver/calibrator/main.py"
      provides: "Headless entry point that wires RosBridge + RecordingManager + CalibrationController"
      min_lines: 30
    - path: "setup.py"
      provides: "Entry point registration for calibrator_cli"
      contains: "calibrator_cli"
  key_links:
    - from: "myactuator_python_driver/calibrator/main.py"
      to: "myactuator_python_driver/studio/ros_bridge.py"
      via: "Creates RosBridge instance and calls start()"
      pattern: "RosBridge.*start"
    - from: "myactuator_python_driver/calibrator/main.py"
      to: "myactuator_python_driver/calibrator/controller.py"
      via: "Creates CalibrationController with ros_bridge and recording_manager"
      pattern: "CalibrationController.*ros_bridge.*recording_manager"
    - from: "setup.py"
      to: "myactuator_python_driver/calibrator/main.py"
      via: "console_scripts entry point"
      pattern: "calibrator_cli.*calibrator\\.main"
---

<objective>
Create the headless entry point and register it as a ROS 2 console_scripts command, then verify the complete calibration flow works end-to-end.

Purpose: Provides a runnable command (`ros2 run myactuator_python_driver calibrator_cli`) that wires up the CalibrationController with real RosBridge and RecordingManager instances. This serves as both the Phase 1 deliverable (headless calibration) and a foundation for Phase 2 to replace with a GUI entry point.

Output: A working CLI entry point and setup.py registration. Verified via human checkpoint against a connected driver.
</objective>

<execution_context>
@/home/nitish/.claude/get-shit-done/workflows/execute-plan.md
@/home/nitish/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-safety-infrastructure-core-controller/01-RESEARCH.md
@.planning/phases/01-safety-infrastructure-core-controller/01-01-SUMMARY.md
@myactuator_python_driver/studio/ros_bridge.py
@myactuator_python_driver/studio/recording_manager.py
@myactuator_python_driver/studio/main.py
@myactuator_python_driver/calibrator/controller.py
@myactuator_python_driver/calibrator/config.py
@setup.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create headless entry point and register in setup.py</name>
  <files>
    myactuator_python_driver/calibrator/main.py
    setup.py
  </files>
  <action>
**calibrator/main.py** -- Create a headless CLI entry point that demonstrates the calibration flow. Follow the same pattern as `studio/main.py` for Qt app setup, ROS 2 checks, and logging suppression.

Structure:
1. Suppress ROS 2 logging noise (same as studio/main.py)
2. Import and check PyQt6, rclpy, rosbag2_py availability (print errors to stderr, no QMessageBox since headless)
3. Create QCoreApplication (not QApplication -- no GUI needed in Phase 1)
4. Create RosBridge and RecordingManager instances
5. Create CalibrationController(ros_bridge, recording_manager)
6. Wire signals:
   - `ros_bridge.joint_state_received` -> `controller._on_joint_state` (already done in controller __init__, so verify this is not double-connected)
   - `controller.state_changed` -> print state to stdout
   - `controller.error_occurred` -> print error to stderr
   - `controller.calibration_complete` -> print result to stdout, then quit
   - `controller.position_updated` -> (optional) print at reduced rate for feedback
   - `controller.max_position_updated` -> print to stdout
7. Start ros_bridge
8. Parse command-line arguments for: `--joint` (required), `--torque` (required, float in Nm), `--name` (optional recording name), `--offset` (optional, default 0.5 degrees)
9. Use `argparse` for argument parsing
10. After RosBridge connects (listen for `connection_status_changed(True)`), create CalibrationConfig from args and call `controller.start_calibration(config)`
11. Set up a signal handler for SIGINT that calls `controller.emergency_stop()` then `app.quit()`
12. Print instructions: "Press Ctrl+C to emergency stop. Calibration will run until stopped."
13. Use a QTimer.singleShot approach: after connection, wait 1 second for joint names to populate, then start calibration
14. For stopping: since this is headless Phase 1, add a second SIGINT handler or use a QTimer-based approach where the user presses Ctrl+C once to stop gracefully (calls stop_calibration) and twice to emergency stop. Simpler approach: first Ctrl+C calls stop_calibration, subsequent Ctrl+C calls emergency_stop.
15. Run `app.exec()`

**setup.py** -- Add entry point to console_scripts:
```python
'calibrator_cli = myactuator_python_driver.calibrator.main:main',
```

Add it after the existing `motor_studio` entry in the console_scripts list.

**Important:** Use QCoreApplication (from PyQt6.QtCore), not QApplication, since this is a headless entry point. This avoids requiring a display server.
  </action>
  <verify>
    python3 -c "from myactuator_python_driver.calibrator.main import main; print('Entry point importable')" && grep -q "calibrator_cli" setup.py && echo "setup.py updated"
  </verify>
  <done>
    calibrator/main.py exists with a main() function that creates QCoreApplication, RosBridge, RecordingManager, CalibrationController with correct wiring. setup.py has the calibrator_cli entry point. Entry point is importable.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify end-to-end calibration flow against live hardware</name>
  <action>
    Human verifies the complete headless calibration system works against a connected driver with real motors.

    Prerequisites: Driver node running, CAN connected, motors powered.

    1. Rebuild the package:
       ```
       colcon build --packages-select myactuator_python_driver
       source install/setup.bash
       ```

    2. Run the calibrator CLI (replace joint1 and torque value with your setup):
       ```
       ros2 run myactuator_python_driver calibrator_cli --joint joint1 --torque 0.5
       ```

    3. Verify the following behaviors:
       - Console prints "Connected to driver" when RosBridge connects
       - Console prints state transition to RECORDING
       - The selected joint receives torque (physically moves)
       - Other joints are free (can be moved by hand)
       - Console prints position updates and max position updates
       - A recording bag is created in the recordings directory

    4. Press Ctrl+C to stop:
       - Torque should cease immediately
       - Console prints CalibrationResult with max_position_rad, duration, recording name
       - Motors return to position mode (hold position)

    5. Test emergency stop: Run again, but press Ctrl+C twice quickly:
       - Motors should stop immediately via emergency_stop service

    6. Test connection loss: Run calibrator, then kill the driver node:
       - Calibrator should detect disconnection within ~2 seconds
       - State should transition to ERROR
       - Torque should stop, recording should stop

    Expected outcome: All 6 checks pass.
  </action>
  <verify>Human confirms all 6 test scenarios pass</verify>
  <done>Headless calibrator correctly orchestrates torque application, position tracking, bag recording, and safety across all scenarios</done>
  <resume-signal>Type "approved" or describe any issues observed</resume-signal>
</task>

</tasks>

<verification>
1. calibrator/main.py exists with main() function
2. setup.py contains calibrator_cli entry point pointing to calibrator.main:main
3. `ros2 run myactuator_python_driver calibrator_cli --help` shows --joint, --torque, --name, --offset arguments
4. Full calibration cycle (start -> apply torque -> track position -> stop -> result) works against live hardware
5. Emergency stop works from CLI (Ctrl+C)
6. Connection loss detection triggers ERROR state and safe shutdown
</verification>

<success_criteria>
- `ros2 run myactuator_python_driver calibrator_cli --joint <name> --torque <value>` starts calibration
- Selected joint receives torque, other joints are free
- Ctrl+C stops calibration gracefully and prints result
- Connection loss during calibration triggers error and safe shutdown
- Recording bag is saved to recordings directory
</success_criteria>

<output>
After completion, create `.planning/phases/01-safety-infrastructure-core-controller/01-02-SUMMARY.md`
</output>
