---
phase: 01-safety-infrastructure-core-controller
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - myactuator_python_driver/calibrator/__init__.py
  - myactuator_python_driver/calibrator/config.py
  - myactuator_python_driver/calibrator/controller.py
autonomous: true

must_haves:
  truths:
    - "CalibrationController applies configured torque to selected joint while sending zero effort to all other joints"
    - "Emergency stop immediately ceases torque and returns motors to safe state from any controller state"
    - "Controller detects connection loss during recording and aborts to ERROR state"
    - "Max position tracking captures the highest position reached in the direction of applied torque"
    - "Bag recording starts before torque application and stops after torque is zeroed"
    - "Periodic effort refresh (100ms) guards against dropped ROS messages"
  artifacts:
    - path: "myactuator_python_driver/calibrator/__init__.py"
      provides: "Package init with public API exports"
      contains: "CalibrationController"
    - path: "myactuator_python_driver/calibrator/config.py"
      provides: "CalibrationState enum, CalibrationConfig and CalibrationResult dataclasses"
      exports: ["CalibrationState", "CalibrationConfig", "CalibrationResult"]
    - path: "myactuator_python_driver/calibrator/controller.py"
      provides: "CalibrationController QObject with state machine, torque orchestration, safety"
      exports: ["CalibrationController"]
      min_lines: 150
  key_links:
    - from: "myactuator_python_driver/calibrator/controller.py"
      to: "myactuator_python_driver/studio/ros_bridge.py"
      via: "RosBridge.set_mode, send_joint_command, emergency_stop, connection_status_changed, joint_state_received"
      pattern: "ros_bridge\\.(set_mode|send_joint_command|emergency_stop)"
    - from: "myactuator_python_driver/calibrator/controller.py"
      to: "myactuator_python_driver/studio/recording_manager.py"
      via: "RecordingManager.start_recording, stop_recording, record_frame, is_recording"
      pattern: "recording_manager\\.(start_recording|stop_recording|record_frame)"
    - from: "myactuator_python_driver/calibrator/controller.py"
      to: "myactuator_python_driver/calibrator/config.py"
      via: "Imports CalibrationState, CalibrationConfig, CalibrationResult"
      pattern: "from.*calibrator\\.config import"
---

<objective>
Build the CalibrationController with its data models -- the core orchestration logic for automated torque threshold calibration.

Purpose: This is the headless engine that coordinates torque application, position tracking, bag recording, and safety monitoring. It reuses RosBridge and RecordingManager (no new ROS nodes or driver modifications). Phase 2 will wrap this controller with a PyQt6 UI.

Output: Three files forming the calibrator package core -- an enum-based state machine controller that can start/stop calibration, apply per-joint torque, track max position, handle emergency stop, and detect connection loss.
</objective>

<execution_context>
@/home/nitish/.claude/get-shit-done/workflows/execute-plan.md
@/home/nitish/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-safety-infrastructure-core-controller/01-RESEARCH.md
@myactuator_python_driver/studio/ros_bridge.py
@myactuator_python_driver/studio/recording_manager.py
@myactuator_python_driver/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create calibrator data models (config.py and __init__.py)</name>
  <files>
    myactuator_python_driver/calibrator/__init__.py
    myactuator_python_driver/calibrator/config.py
  </files>
  <action>
Create the `calibrator/` package directory under `myactuator_python_driver/`.

**calibrator/config.py** -- Define three items:

1. `CalibrationState` enum (Python `enum.Enum` with `auto()`):
   - `IDLE` -- ready, not recording
   - `RECORDING` -- torque applied, bag recording, tracking max position
   - `STOPPING` -- transitioning back to safe state
   - `ERROR` -- something went wrong (connection lost, etc.)

2. `CalibrationConfig` dataclass:
   - `joint_name: str` -- which joint receives torque
   - `torque_nm: float` -- torque to apply (signed, direction matters)
   - `recording_name: str = ""` -- optional recording name (auto-generated if empty)
   - `offset_deg: float = 0.5` -- threshold offset in degrees (used in Phase 3)

3. `CalibrationResult` dataclass:
   - `recording_name: str` -- name of the bag recording
   - `joint_name: str` -- which joint was calibrated
   - `max_position_rad: float` -- highest position reached in torque direction
   - `torque_nm: float` -- torque that was applied
   - `duration_sec: float` -- how long calibration ran

**calibrator/__init__.py** -- Export all public types:
```python
from .config import CalibrationState, CalibrationConfig, CalibrationResult
from .controller import CalibrationController
```

Note: The __init__.py import of CalibrationController will error until Task 2 creates controller.py. That is fine -- both tasks are in the same plan and will be executed sequentially.
  </action>
  <verify>
    python3 -c "from myactuator_python_driver.calibrator.config import CalibrationState, CalibrationConfig, CalibrationResult; print(list(CalibrationState)); print(CalibrationConfig(joint_name='j1', torque_nm=1.0)); print(CalibrationResult(recording_name='r', joint_name='j', max_position_rad=0.5, torque_nm=1.0, duration_sec=2.0))"
  </verify>
  <done>
    CalibrationState has 4 members (IDLE, RECORDING, STOPPING, ERROR). CalibrationConfig accepts joint_name, torque_nm, recording_name, offset_deg. CalibrationResult accepts all 5 fields. All are importable from calibrator.config.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement CalibrationController with state machine and safety logic</name>
  <files>
    myactuator_python_driver/calibrator/controller.py
  </files>
  <action>
Create `CalibrationController` as a QObject with the following structure. Use the existing RosBridge and RecordingManager -- do NOT create any new ROS nodes, publishers, or subscribers.

**Signals (pyqtSignal):**
- `state_changed(object)` -- emits CalibrationState on transitions
- `max_position_updated(float)` -- current max position in radians
- `position_updated(float)` -- current joint position in radians
- `error_occurred(str)` -- error message string
- `calibration_complete(object)` -- emits CalibrationResult on successful completion

**Constructor `__init__(self, ros_bridge, recording_manager, parent=None)`:**
- Store references to ros_bridge (RosBridge) and recording_manager (RecordingManager)
- Initialize `_state = CalibrationState.IDLE`
- Initialize `_config = None`, `_max_position_rad = None`, `_start_time = 0.0`, `_effort_timer = None`
- Connect `ros_bridge.joint_state_received` to `self._on_joint_state`
- Connect `ros_bridge.connection_status_changed` to `self._on_connection_changed`

**Property `state` -> CalibrationState:** Returns current state.

**Property `is_active` -> bool:** Returns True if state is RECORDING or STOPPING.

**Method `start_calibration(self, config: CalibrationConfig) -> bool`:**
1. Guard: if state is not IDLE, emit error_occurred("Cannot start: calibration already in progress"), return False
2. Guard: if `not ros_bridge.is_connected`, emit error_occurred("Cannot start: driver not connected"), return False
3. Store config. Set `_max_position_rad = None` (will initialize from first joint state). Set `_start_time = time.time()`.
4. Generate recording name if empty: `f"calib_{config.joint_name}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"`
5. Start recording FIRST: `recording_manager.start_recording(recording_name)`. If returns False, emit error and return False.
6. Set torque mode: `ros_bridge.set_mode("torque")`
7. Send initial effort command via `_send_effort_command()`
8. Create QTimer for periodic effort refresh at 100ms interval, connect to `_send_effort_command`
9. Set state to RECORDING, emit state_changed
10. Return True

**Method `stop_calibration(self) -> Optional[CalibrationResult]`:**
1. If state is not RECORDING, return None
2. Set state to STOPPING, emit state_changed
3. Stop effort timer (stop + deleteLater or set to None)
4. Zero all efforts: build JointState with all joint names from `ros_bridge.joint_names`, all efforts 0.0, call `ros_bridge.send_joint_command(msg)`
5. Switch mode to "position": `ros_bridge.set_mode("position")`
6. Stop recording: `recording_manager.stop_recording()`
7. Build CalibrationResult with recording_name, joint_name, max_position_rad (use 0.0 if None), torque_nm, duration_sec
8. Set state to IDLE, emit state_changed
9. Emit calibration_complete with the result
10. Return the result

**Method `emergency_stop(self)`:**
1. Call `ros_bridge.emergency_stop()` FIRST (immediate motor stop)
2. If effort timer exists, stop it
3. If recording_manager.is_recording, stop recording
4. Set state to IDLE (not ERROR -- e-stop is intentional user action), emit state_changed

**Internal `_send_effort_command(self)`:**
- Build a `sensor_msgs.msg.JointState` message
- `msg.name = list(ros_bridge.joint_names)`
- `msg.effort = [config.torque_nm if name == config.joint_name else 0.0 for name in msg.name]`
- Call `ros_bridge.send_joint_command(msg)`
- Leave position and velocity arrays empty (driver only reads effort in torque mode)

**Internal `_on_joint_state(self, msg)`:**
- If state is not RECORDING, return early
- Find selected joint index: `idx = list(msg.name).index(config.joint_name)` (guard with try/except ValueError, return if not found)
- Get position: `msg.position[idx]`
- Emit `position_updated(position)`
- **Max position tracking with direction awareness:**
  - If `_max_position_rad is None`: initialize to current position (handles Pitfall 4 from research)
  - If `config.torque_nm >= 0`: track max (update if position > _max_position_rad)
  - If `config.torque_nm < 0`: track min (update if position < _max_position_rad)
  - On update, emit `max_position_updated(_max_position_rad)`
- **Record frame to bag:** Call `recording_manager.record_frame(msg, int(time.time() * 1e9))`

**Internal `_on_connection_changed(self, connected: bool)`:**
- If `not connected` and state is RECORDING:
  - Stop effort timer
  - If recording, stop recording
  - Set state to ERROR, emit state_changed
  - Emit error_occurred("Connection to driver lost during calibration")

**Important implementation notes (from research anti-patterns):**
- Do NOT import or use rclpy directly -- all ROS communication goes through RosBridge
- Do NOT subclass QThread -- CalibrationController is a QObject
- Do NOT use QStateMachine framework -- plain enum with manual transitions
- Do NOT modify driver_node.py
- All state transitions must be non-blocking
  </action>
  <verify>
    python3 -c "
from PyQt6.QtWidgets import QApplication
import sys
app = QApplication(sys.argv)
from myactuator_python_driver.calibrator.controller import CalibrationController
from myactuator_python_driver.calibrator.config import CalibrationState, CalibrationConfig, CalibrationResult
# Verify class exists and has expected signals
assert hasattr(CalibrationController, 'state_changed')
assert hasattr(CalibrationController, 'max_position_updated')
assert hasattr(CalibrationController, 'position_updated')
assert hasattr(CalibrationController, 'error_occurred')
assert hasattr(CalibrationController, 'calibration_complete')
# Verify methods exist
assert hasattr(CalibrationController, 'start_calibration')
assert hasattr(CalibrationController, 'stop_calibration')
assert hasattr(CalibrationController, 'emergency_stop')
print('All checks passed')
"
  </verify>
  <done>
    CalibrationController is importable from calibrator.controller. It has 5 pyqtSignals (state_changed, max_position_updated, position_updated, error_occurred, calibration_complete). It has start_calibration, stop_calibration, and emergency_stop methods. Constructor accepts ros_bridge and recording_manager parameters. The __init__.py exports all 4 public types.
  </done>
</task>

</tasks>

<verification>
1. All three files exist: calibrator/__init__.py, calibrator/config.py, calibrator/controller.py
2. CalibrationState enum has exactly 4 members: IDLE, RECORDING, STOPPING, ERROR
3. CalibrationConfig has fields: joint_name, torque_nm, recording_name (default ""), offset_deg (default 0.5)
4. CalibrationResult has fields: recording_name, joint_name, max_position_rad, torque_nm, duration_sec
5. CalibrationController inherits QObject, has 5 signals, 3 public methods
6. Controller imports RosBridge methods (set_mode, send_joint_command, emergency_stop) -- not rclpy directly
7. Controller imports RecordingManager methods (start_recording, stop_recording, record_frame)
8. _on_joint_state tracks max position with direction awareness (positive torque = max, negative = min)
9. _on_joint_state initializes max position from first reading (not 0.0)
10. start_calibration starts recording BEFORE sending torque command
11. stop_calibration zeros effort BEFORE switching mode
12. Effort refresh timer runs at 100ms interval during RECORDING
</verification>

<success_criteria>
- `from myactuator_python_driver.calibrator import CalibrationController, CalibrationState, CalibrationConfig, CalibrationResult` succeeds without error
- CalibrationController can be instantiated with mock ros_bridge and recording_manager objects
- No rclpy imports in controller.py (all ROS via RosBridge)
- No QThread subclassing (controller is QObject)
</success_criteria>

<output>
After completion, create `.planning/phases/01-safety-infrastructure-core-controller/01-01-SUMMARY.md`
</output>
