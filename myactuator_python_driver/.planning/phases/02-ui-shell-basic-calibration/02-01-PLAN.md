---
phase: 02-ui-shell-basic-calibration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - myactuator_python_driver/myactuator_python_driver/calibrator/window.py
  - myactuator_python_driver/myactuator_python_driver/calibrator/main.py
  - myactuator_python_driver/myactuator_python_driver/calibrator/__init__.py
  - myactuator_python_driver/setup.py
autonomous: false

must_haves:
  truths:
    - "User can launch the calibration app from the command line via `calibrator_app`"
    - "User sees a dropdown populated with connected motor joint names"
    - "User can set torque (Nm) and threshold offset (degrees) via spinboxes with unit suffixes"
    - "User can type a recording name or leave empty for auto-generation"
    - "User can press Record to start calibration and press Stop to end it"
    - "App displays live joint position and running max position during active calibration"
    - "App shows torque direction indicator that updates when torque value changes"
    - "All configuration inputs are disabled during active recording"
    - "Record button is disabled when driver is not connected"
    - "App shows visible connection status (green Connected / red Disconnected)"
  artifacts:
    - path: "myactuator_python_driver/myactuator_python_driver/calibrator/window.py"
      provides: "CalibrationWindow QMainWindow with all UI widgets and signal wiring"
      contains: "class CalibrationWindow"
    - path: "myactuator_python_driver/myactuator_python_driver/calibrator/main.py"
      provides: "GUI entry point function main_gui()"
      contains: "def main_gui"
    - path: "myactuator_python_driver/setup.py"
      provides: "console_scripts entry point for calibrator_app"
      contains: "calibrator_app"
  key_links:
    - from: "calibrator/window.py"
      to: "calibrator/controller.py"
      via: "signal connections in _connect_signals()"
      pattern: "self._controller\\.state_changed\\.connect"
    - from: "calibrator/window.py"
      to: "studio/ros_bridge.py"
      via: "connection_status_changed and joint_state_received signals"
      pattern: "self._ros_bridge\\.connection_status_changed\\.connect"
    - from: "calibrator/main.py"
      to: "calibrator/window.py"
      via: "import and instantiation in main_gui()"
      pattern: "CalibrationWindow\\(\\)"
    - from: "setup.py"
      to: "calibrator/main.py"
      via: "console_scripts entry point"
      pattern: "calibrator_app.*main_gui"
---

<objective>
Create the CalibrationWindow PyQt6 GUI and register it as a standalone application entry point.

Purpose: Expose the Phase 1 CalibrationController through a graphical interface so users can configure and execute calibrations without the CLI. This is the primary user-facing delivery of Phase 2.

Output: CalibrationWindow (QMainWindow) in window.py, main_gui() entry point in main.py, calibrator_app console_scripts registration in setup.py.
</objective>

<execution_context>
@/home/nitish/.claude/get-shit-done/workflows/execute-plan.md
@/home/nitish/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-safety-infrastructure-core-controller/01-01-SUMMARY.md
@.planning/phases/01-safety-infrastructure-core-controller/01-02-SUMMARY.md
@.planning/phases/02-ui-shell-basic-calibration/02-RESEARCH.md
@myactuator_python_driver/myactuator_python_driver/calibrator/controller.py
@myactuator_python_driver/myactuator_python_driver/calibrator/config.py
@myactuator_python_driver/myactuator_python_driver/calibrator/main.py
@myactuator_python_driver/myactuator_python_driver/calibrator/__init__.py
@myactuator_python_driver/myactuator_python_driver/studio/main.py
@myactuator_python_driver/myactuator_python_driver/studio/main_window.py
@myactuator_python_driver/setup.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CalibrationWindow with UI layout and signal wiring</name>
  <files>
    myactuator_python_driver/myactuator_python_driver/calibrator/window.py
    myactuator_python_driver/myactuator_python_driver/calibrator/__init__.py
  </files>
  <action>
Create `calibrator/window.py` containing `CalibrationWindow(QMainWindow)` that owns RosBridge, RecordingManager, and CalibrationController. Follow the exact ownership pattern from `studio/main_window.py` (lines 44-53).

**Constructor (`__init__`):**
- Set window title "Torque Threshold Calibrator", minimum size 500x600
- Create `self._ros_bridge = RosBridge(self)`, `self._recording_manager = RecordingManager(self)`, `self._controller = CalibrationController(self._ros_bridge, self._recording_manager, parent=self)`
- Track `self._connected = False` for connection state
- Call `self._setup_ui()`, `self._connect_signals()`, `self._ros_bridge.start()`

**Layout (`_setup_ui`):**
- Central widget with QVBoxLayout, margins 16px, spacing 16px
- Connection status label at top: `self._connection_label = QLabel("Disconnected")` with red color `#ef5350` and bold font
- Configuration QGroupBox "Configuration" with QFormLayout containing:
  - `self._joint_combo = QComboBox()` with placeholder text "(waiting for joints...)" via `setPlaceholderText()`
  - `self._torque_spin = QDoubleSpinBox()` with range -50.0 to +50.0, decimals 2, step 0.1, suffix " Nm", default 1.0
  - `self._offset_spin = QDoubleSpinBox()` with range 0.0 to 90.0, decimals 1, step 0.1, suffix " deg", default 0.5
  - `self._name_edit = QLineEdit()` with placeholder "Auto-generated if empty"
- Direction indicator: `self._direction_label = QLabel("Direction: Positive (increasing position)")` styled blue `#90caf9`
- Live data QGroupBox "Live Data" with QFormLayout containing:
  - `self._position_label = QLabel("--")` with 18px bold font
  - `self._max_position_label = QLabel("--")` with 18px bold font, orange color `#ff9800`
- Record/Stop button: `self._record_btn = QPushButton("Record")` with bold 16px font, 16px padding, 60px min height
- Emergency stop button: `self._estop_btn = QPushButton("EMERGENCY STOP")` with red background `#d32f2f`, white text, bold 14px font, 8px border-radius, 12px padding, 50px min height, hover color `#f44336`

**Signal wiring (`_connect_signals`):**
- `self._ros_bridge.connection_status_changed.connect(self._on_connection_changed)`
- `self._ros_bridge.joint_state_received.connect(self._on_joint_state)`
- `self._controller.state_changed.connect(self._on_state_changed)`
- `self._controller.position_updated.connect(self._on_position_updated)`
- `self._controller.max_position_updated.connect(self._on_max_position_updated)`
- `self._controller.error_occurred.connect(self._on_error)`
- `self._controller.calibration_complete.connect(self._on_calibration_complete)`
- `self._torque_spin.valueChanged.connect(self._on_torque_changed)`
- `self._record_btn.clicked.connect(self._on_record_clicked)`
- `self._estop_btn.clicked.connect(self._on_estop)`

**Handlers:**

`_on_connection_changed(self, connected: bool)`:
- Update `self._connected`
- If connected: label text "Connected", style green `#81c784`
- If disconnected: label text "Disconnected", style red `#ef5350`
- Call `self._update_record_button_state()`

`_on_joint_state(self, msg)`:
- Populate joint combo on first message: `if self._joint_combo.count() == 0 and msg.name:` then `self._joint_combo.addItems(list(msg.name))`
- This handles INPT-01 (combo populated from connected joints)

`_on_state_changed(self, state: CalibrationState)`:
- Determine `is_active = state in (CalibrationState.RECORDING, CalibrationState.STOPPING)`
- Disable/enable inputs (INPT-05): `self._joint_combo.setEnabled(not is_active)`, same for `_torque_spin`, `_offset_spin`, `_name_edit`
- If RECORDING: change record button text to "Stop", style it red background
- If IDLE: change record button text to "Record", restore normal style
- Call `self._update_record_button_state()`

`_on_position_updated(self, position_rad: float)`:
- `self._position_label.setText(f"{position_rad:.4f} rad ({math.degrees(position_rad):.2f} deg)")`

`_on_max_position_updated(self, max_pos_rad: float)`:
- `self._max_position_label.setText(f"{max_pos_rad:.4f} rad ({math.degrees(max_pos_rad):.2f} deg)")`

`_on_error(self, message: str)`:
- Show error in status bar or connection label area. Use `self.statusBar().showMessage(f"Error: {message}", 5000)` (QMainWindow has statusBar()).

`_on_calibration_complete(self, result)`:
- Show completion message in status bar: `self.statusBar().showMessage(f"Calibration complete: {result.joint_name} threshold={math.degrees(result.max_position_rad):.2f} deg", 10000)`
- Reset position labels to "--"

`_on_torque_changed(self, value: float)`:
- If value > 0: "Direction: Positive (increasing position)"
- If value < 0: "Direction: Negative (decreasing position)"
- If value == 0: "Direction: None (zero torque)"

`_on_record_clicked(self)`:
- If `self._controller.is_active`: call `self._controller.stop_calibration()`
- Else: build `CalibrationConfig` from UI inputs:
  - `joint_name=self._joint_combo.currentText()`
  - `torque_nm=self._torque_spin.value()`
  - `offset_deg=self._offset_spin.value()`
  - `recording_name=self._name_edit.text().strip()`
  - Call `self._controller.start_calibration(config)`. Controller handles guards.

`_on_estop(self)`:
- Call `self._controller.emergency_stop()`

`_update_record_button_state(self)`:
- Disable record button if not connected AND not currently active: `self._record_btn.setEnabled(self._connected or self._controller.is_active)`
- This allows clicking Stop even if connection drops, but prevents starting a new calibration when disconnected.

**closeEvent override:**
- If `self._controller.is_active`: call `self._controller.emergency_stop()`
- Call `self._ros_bridge.stop()`
- Accept the event. (Same pattern as MainWindow.closeEvent)

**Also update `calibrator/__init__.py`** to export CalibrationWindow:
- Add `from .window import CalibrationWindow` and add "CalibrationWindow" to `__all__`

**Imports needed in window.py:**
- `import math`
- `from PyQt6.QtWidgets import QMainWindow, QWidget, QVBoxLayout, QFormLayout, QGroupBox, QComboBox, QDoubleSpinBox, QLineEdit, QLabel, QPushButton`
- `from myactuator_python_driver.studio.ros_bridge import RosBridge`
- `from myactuator_python_driver.studio.recording_manager import RecordingManager`
- `from .controller import CalibrationController`
- `from .config import CalibrationConfig, CalibrationState`

**Do NOT:**
- Put any calibration logic in the window (all logic is in CalibrationController)
- Create a second RosBridge with custom node name (accept same node name limitation for now)
- Use QThread for the controller (it's a QObject on the main thread)
- Poll for position in a QTimer (controller pushes via signals)
  </action>
  <verify>
Verify window.py exists and contains:
- `class CalibrationWindow(QMainWindow)`
- `_setup_ui` method with all required widgets (joint combo, torque spin, offset spin, name edit, record button, estop button, position labels, direction label, connection label)
- `_connect_signals` method wiring ros_bridge, controller, and widget signals
- `_on_state_changed` handler that disables inputs during recording (INPT-05)
- `_on_connection_changed` handler that updates connection label
- `_on_joint_state` handler that populates joint combo (INPT-01)
- `_on_torque_changed` handler that updates direction label (DISP-03)
- `closeEvent` override calling emergency_stop and ros_bridge.stop
- `_update_record_button_state` that disables Record when disconnected

Verify __init__.py exports CalibrationWindow.

Run: `cd /home/nitish/work/myactuator && python3 -c "from myactuator_python_driver.calibrator.window import CalibrationWindow; print('Import OK')"` (may fail without ROS -- import check only if env available)
  </verify>
  <done>
CalibrationWindow class exists in window.py with all UI widgets for INPT-01 through INPT-05, CALB-01, CALB-05, DISP-01 through DISP-03. Signal wiring connects controller outputs to UI labels and controller inputs to UI buttons. Inputs disable during recording. Record button disabled when disconnected. Emergency stop and closeEvent safety cleanup implemented.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create GUI entry point and register console_scripts</name>
  <files>
    myactuator_python_driver/myactuator_python_driver/calibrator/main.py
    myactuator_python_driver/setup.py
  </files>
  <action>
**Add `main_gui()` function to `calibrator/main.py`** (alongside existing `main()` CLI function). Follow the exact pattern from `studio/main.py`:

```python
def main_gui():
    """GUI entry point for Torque Threshold Calibrator."""
    import logging
    logging.getLogger('rosbag2_cpp').setLevel(logging.CRITICAL)
    logging.getLogger('rosbag2_storage_mcap').setLevel(logging.CRITICAL)
    logging.getLogger('rcl').setLevel(logging.CRITICAL)

    try:
        from PyQt6.QtWidgets import QApplication, QMessageBox
        from PyQt6.QtCore import Qt
    except ImportError:
        print("Error: PyQt6 is required but not installed.")
        print("Install it with: pip install PyQt6")
        sys.exit(1)

    app = QApplication(sys.argv)
    app.setApplicationName("Torque Threshold Calibrator")

    # Apply qt-material theme if available (copy from studio/main.py exactly)
    try:
        from qt_material import apply_stylesheet
        apply_stylesheet(app, theme='dark_blue.xml')
    except ImportError:
        from PyQt6.QtWidgets import QStyleFactory
        from PyQt6.QtGui import QPalette, QColor
        app.setStyle(QStyleFactory.create("Fusion"))
        palette = QPalette()
        palette.setColor(QPalette.ColorRole.Window, QColor(53, 53, 53))
        palette.setColor(QPalette.ColorRole.WindowText, Qt.GlobalColor.white)
        palette.setColor(QPalette.ColorRole.Base, QColor(25, 25, 25))
        palette.setColor(QPalette.ColorRole.AlternateBase, QColor(53, 53, 53))
        palette.setColor(QPalette.ColorRole.ToolTipBase, Qt.GlobalColor.white)
        palette.setColor(QPalette.ColorRole.ToolTipText, Qt.GlobalColor.white)
        palette.setColor(QPalette.ColorRole.Text, Qt.GlobalColor.white)
        palette.setColor(QPalette.ColorRole.Button, QColor(53, 53, 53))
        palette.setColor(QPalette.ColorRole.ButtonText, Qt.GlobalColor.white)
        palette.setColor(QPalette.ColorRole.BrightText, Qt.GlobalColor.red)
        palette.setColor(QPalette.ColorRole.Link, QColor(42, 130, 218))
        palette.setColor(QPalette.ColorRole.Highlight, QColor(42, 130, 218))
        palette.setColor(QPalette.ColorRole.HighlightedText, Qt.GlobalColor.black)
        app.setPalette(palette)

    # Check for ROS 2 availability (use QMessageBox since we have GUI)
    try:
        import rclpy
    except ImportError:
        QMessageBox.critical(
            None,
            "ROS 2 Not Found",
            "ROS 2 Python packages (rclpy) are not available.\n\n"
            "Make sure you have:\n"
            "1. Installed ROS 2\n"
            "2. Sourced the ROS 2 setup file\n"
            "3. Built and sourced your workspace"
        )
        sys.exit(1)

    try:
        import rosbag2_py
    except ImportError:
        QMessageBox.critical(
            None,
            "rosbag2 Not Found",
            "rosbag2_py is not available.\n\n"
            "Make sure ros-<distro>-rosbag2 is installed."
        )
        sys.exit(1)

    from myactuator_python_driver.calibrator.window import CalibrationWindow
    window = CalibrationWindow()
    window.show()
    sys.exit(app.exec())
```

Note: The existing `main()` function at the top of the file already imports `sys` at the module level. The `main_gui()` function can use the same module-level `sys` import. Keep the existing `main()` function and `if __name__` block untouched.

**Add `calibrator_app` entry point to `setup.py`:**
Add this line to the console_scripts list:
```
'calibrator_app = myactuator_python_driver.calibrator.main:main_gui',
```

Place it after the existing `calibrator_cli` line.
  </action>
  <verify>
Verify main.py contains both `def main():` (existing CLI) and `def main_gui():` (new GUI).

Verify setup.py contains `calibrator_app` entry pointing to `main_gui`.

Run: `cd /home/nitish/work/myactuator && python3 -c "from myactuator_python_driver.calibrator.main import main_gui; print('main_gui import OK')"`

Run: `cd /home/nitish/work/myactuator && grep 'calibrator_app' myactuator_python_driver/setup.py` -- should show the entry point line.

Build check: `cd /home/nitish/work/myactuator && colcon build --packages-select myactuator_python_driver 2>&1 | tail -5` -- should succeed.
  </verify>
  <done>
main_gui() function exists in calibrator/main.py following the exact studio/main.py pattern (dark theme, dependency checks with QMessageBox, CalibrationWindow creation). setup.py registers `calibrator_app` console_scripts entry point pointing to main_gui. The app can be launched via `ros2 run myactuator_python_driver calibrator_app` or directly as `calibrator_app` after installation.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify calibration app launches and functions</name>
  <action>
Human verifies the complete calibration GUI works against a connected driver with real motors.

**What was built:**
Complete CalibrationWindow GUI with joint dropdown, torque/offset spinboxes, recording name field, Record/Stop toggle button, Emergency Stop button, live position and max position display, torque direction indicator, connection status indicator, and input disable during active recording.

**Verification steps:**

1. Build the workspace:
   ```
   cd /home/nitish/work/myactuator
   colcon build --packages-select myactuator_python_driver
   source install/setup.bash
   ```

2. Launch the app (with driver running):
   ```
   ros2 run myactuator_python_driver calibrator_app
   ```

3. Verify these behaviors:
   - Window appears with title "Torque Threshold Calibrator"
   - Connection label shows "Connected" in green (if driver is running)
   - Joint dropdown is populated with joint names from the driver
   - Torque spinbox shows "Nm" suffix, range -50 to +50
   - Offset spinbox shows "deg" suffix, default 0.5
   - Recording name field shows placeholder "Auto-generated if empty"
   - Changing torque sign updates the direction indicator text
   - Click Record: inputs disable, button changes to "Stop", live position updates
   - Click Stop: inputs re-enable, button changes back to "Record"
   - Emergency Stop button stops calibration immediately
   - Closing window during calibration stops torque and cleans up
   - Without driver running: connection label shows "Disconnected" in red, Record button is disabled

Type "approved" or describe issues to continue.
  </action>
  <verify>All 13 verification behaviors confirmed by human tester.</verify>
  <done>Calibration app launches, displays all required widgets, connects to driver, executes calibration with live position updates, and handles stop/emergency stop correctly.</done>
</task>

</tasks>

<verification>
Phase 2 requirements coverage:
- INPT-01: Joint combo populated from RosBridge.joint_names via joint_state_received signal
- INPT-02: QDoubleSpinBox for torque with range -50 to +50 Nm, step 0.1, suffix " Nm"
- INPT-03: QDoubleSpinBox for offset with range 0 to 90 deg, step 0.1, suffix " deg", default 0.5
- INPT-04: QLineEdit for recording name with auto-generation placeholder
- INPT-05: All inputs disabled when state is RECORDING or STOPPING
- CALB-01: Record button calls controller.start_calibration()
- CALB-05: Same button in Stop mode calls controller.stop_calibration()
- DISP-01: position_updated signal connected to position label
- DISP-02: max_position_updated signal connected to max position label
- DISP-03: torque_spin.valueChanged updates direction label text
- INFR-01: Standalone QMainWindow, not a Motor Studio tab
- INFR-05: calibrator_app console_scripts entry point in setup.py

Build verification: `colcon build --packages-select myactuator_python_driver` succeeds.
</verification>

<success_criteria>
1. `calibrator_app` entry point is registered and launchable
2. CalibrationWindow displays all required input widgets with validation
3. Joint dropdown populates from connected motors
4. Record/Stop button toggles calibration via CalibrationController
5. Live position and max position update at joint state rate during recording
6. Direction indicator reflects torque sign
7. Inputs disable during active recording
8. Record button disabled when driver is disconnected
9. Connection status visible at all times
10. Emergency stop and close event safety cleanup work
</success_criteria>

<output>
After completion, create `.planning/phases/02-ui-shell-basic-calibration/02-01-SUMMARY.md`
</output>
